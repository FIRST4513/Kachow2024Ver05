package frc.robot.XBoxCtrlrs.operator.commands;

import java.util.HashMap;
import java.util.function.BooleanSupplier;
import java.util.function.DoubleSupplier;

import com.google.flatbuffers.FlexBuffers.Map;

import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.ParallelCommandGroup;
import edu.wpi.first.wpilibj2.command.PrintCommand;
import edu.wpi.first.wpilibj2.command.SelectCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj2.command.WaitUntilCommand;
import frc.robot.Robot;
import frc.robot.mechanisms.arm.ArmConfig;
import frc.robot.mechanisms.arm.commands.ArmCmds;
import frc.robot.mechanisms.elevator.commands.ElevatorCmds;
import frc.robot.mechanisms.shooter.ShooterSubSys.FireState;

public class ArmElevComboMoveCmds2{
        public static enum TargetPosition {
        SAFE_TRAVEL,
        SHOOTER,
        GROUND,
        TRAP,
        AMP
    }

    // The enum used as keys for selecting the command to run.
    private enum CommandSelector {
        ONE, TWO, THREE
    }

    // An example selector method for the selectcommand.  Returns the selector that will select
    // which command to run.  Can base this choice on logical conditions evaluated at runtime.
    private CommandSelector select() {
        return CommandSelector.ONE;
    }

    int getCaseNum(int cnt){ 
        return 3;
    }


    // An example selectcommand.  Will select from the three commands based on the value returned
    // by the selector method at runtime.  Note that selectcommand works on Object(), so the
    // selector does not have to be an enum; it could be any desired type (string, integer,
    // boolean, double...)
    // private final Command m_exampleSelectCommand( ) {
    //   return new SelectCommand(
    //       // Maps selector values to commands
    //       Map.ofEntries(
    //           Map.entry( 1 , case1Cmd()),
    //           Map.entry( 2 , case2Cmd()),
    //           Map.entry( 3 , case3Cmd()),
    //           Map.entry( 4 , case3Cmd())
    //       ),
    //       //getCaseNum(num)
    //       this::select
    //   );
    // }


    public static Command case1Cmd( ) {
        // simply set arm and elevator to their new target poses, there should be no interferences
        return new PrintCommand("Case 1 New Command: Out To Out !!!!");
        // return new ParallelCommandGroup(
        //     setArm(positionTo),
        //     setElev(positionTo)
        // );
    }


    public static Command case2Cmd( ) {
        // simply set arm and elevator to their new target poses, there should be no interferences
        return new PrintCommand("Case 2 New Command: In To In !!!!");
        // return new SequentialCommandGroup(
        //     setElev(positionTo),
        //     new WaitUntilCommand(() -> Robot.elevator.isAtTarget()),
        //     setArm(positionTo)
        // );
    }

    public static Command case3Cmd( ) {
        // move arm to safe travel, move elevator to bottom, then move arm to its intended pos
        return new PrintCommand("Case 3 New Command: Out To In !!!!");
        // return new SequentialCommandGroup(
        //     // ArmCmds.armToSafeTravelCmd().onlyIf(() -> isGround(positionTo)),
        //     setArm(TargetPosition.SAFE_TRAVEL),
        //     new WaitUntilCommand(() -> Robot.arm.isAtSafeTravelPos()),
        //     setElev(TargetPosition.SHOOTER),  // same as bottom
        //     new WaitUntilCommand(() -> Robot.elevator.isAtTarget()),
        //     setArm(positionTo)
        // );
    }

    public static Command case4Cmd( ) {
        // send elev to bottom, move arm to safe, then move arm and elev to intended pos
        return new PrintCommand("Case 4 New Command: In To Out !!!!");
        // return new SequentialCommandGroup(
        //     setElev(TargetPosition.SHOOTER),  // same as bottom
        //     new WaitUntilCommand(() -> Robot.elevator.isAtTarget()),
        //     setArm(TargetPosition.SAFE_TRAVEL),
        //     new WaitUntilCommand(() -> Robot.arm.isAtSafeTravelPos()),
        //     setElev(positionTo),
        //     setArm(positionTo)
        // );
    }




    // public static int getCase(TargetPosition position) {
    //     double currentArmAngle = Robot.arm.getArmCurrentAngle();
        
    //     return angle > ArmConfig.SAFE_TRAVEL_MIN;
    // }

    // public static Command ArmAndElevMoveCmd(DoubleSupplier armAngleGetter, TargetPosition positionTo) {
    //     // Get arm angle at instance of runtime
    //     double angleFrom = armAngleGetter.getAsDouble();
    //     Robot.print("Current arm angle: " + angleFrom);
    // }
    

    // public static int getCase(DoubleSupplier armAngleGetter, TargetPosition positionTo) {
    //     double angleFrom = armAngleGetter.getAsDouble();
        
    //     if (isOutside(angleFrom) && isOutside(positionTo)) { return 1; }
    //     if ()
    // }

    // /* INSIDE vs OUTSIDE boolean getters */
    // public static boolean isInside(double angle) {
    //     return angle < ArmConfig.SAFE_TRAVEL_MIN;
    // }

    // public static boolean isInside(TargetPosition position) {
    //     switch (position) {
    //         case SAFE_TRAVEL: return false;
    //         case SHOOTER:     return true;
    //         case GROUND:      return false;
    //         case AMP:         return false;
    //         case TRAP:        return false;
    //         default:          return true;
    //     }
    // }

    // public static boolean isOutside(double angle) {
    //     return angle > ArmConfig.SAFE_TRAVEL_MIN;
    // }

    // public static boolean isOutside(TargetPosition position) {
    //     return !isInside(position);
    // }

    // /* GND VS NOT GETTERS */
    // public static boolean isGround(String position) {
    //     if (position == "GROUND") return true;
    //     return false;
    // }

    // /* SUB SYS SETTERS */
    // public static Command setArm(TargetPosition tgtPose) {
    //     switch (tgtPose) {
    //         case SAFE_TRAVEL: return ArmCmds.armToSafeTravelCmd();
    //         case SHOOTER:     return ArmCmds.armToShooterCmd();
    //         case GROUND:      return ArmCmds.armToGroundCmd();
    //         case AMP:         return ArmCmds.armToAmpCmd();
    //         case TRAP:        return ArmCmds.armToTrapCmd();
    //         default:          return ArmCmds.armToSafeTravelCmd();
    //     }
    // }

    // public static Command setElev(TargetPosition tgtPose) {
    //     switch (tgtPose) {
    //         case SAFE_TRAVEL: return ElevatorCmds.elevatorStopCmd();
    //         case SHOOTER:     return ElevatorCmds.elevatorSetBottomCmd();  // shooter = bottom
    //         case GROUND:      return ElevatorCmds.elevatorSetGroudCmd();
    //         case AMP:         return ElevatorCmds.elevatorSetMidCmd();
    //         case TRAP:        return ElevatorCmds.elevatorSetTopCmd();
    //         default:          return ElevatorCmds.elevatorStopCmd();
    //     }
    // }

    // public class ArmElevState {
    //     public enum PositionRange {
    //         SHOOTER,
    //         STOW,
    //         SAFE_TO_TRAVEL,
    //         GROUND,
    //         UNSAFE_OUTSIDE
    //     }

    //     private boolean isInside;
    //     private PositionRange positionRange;

    //     public ArmElevState(boolean isInside, PositionRange positionRange) {
    //         this.isInside = isInside;
    //         this.positionRange = positionRange;
    //     }

    //     public ArmElevState fromAngle(double armAngle) {
    //         return this(isInsideFromAngle(armAngle), positionRangeFromAngle(armAngle));
    //     }

    //     public boolean isInsideFromAngle(double angle) {
    //         return angle < 5;
    //     }

    //     public PositionRange positionRangeFromAngle(double angle) {
    //         if (angle < -5) { return PositionRange.SHOOTER; }
    //         else if (angle < 5) { return PositionRange.STORE}
    //     }
    // }

}


